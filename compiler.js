'use strict';

const compiler = require('solc');
const solcABI = require('solc/abi');

const utils = require('./utils.js');

const EventManager = require('ethereum-remix').lib.EventManager;

/*
  trigger compilationFinished, compilerLoaded
*/
function Compiler(handleImportCall) {
  var self = this;

  this.event = new EventManager();

  var compileJSON;
  var compilerAcceptsMultipleFiles;
  var currentVersion;

  function internalCompile(files, target, missingInputs) {
    gatherImports(files, target, missingInputs, function (error, input) {
      if (error) {
        self.lastCompilationResult = null;
        self.event.trigger('compilationFinished', [false, {'error': error}, files]);
      } else {
        compileJSON(input, 0);
      }
    });
  }

  this.compile = internalCompile;

  function onCompilerLoaded(version) {
    currentVersion = version;

    self.event.trigger('compilerLoaded', [version]);
  }

  function loadInternal() {
    compilerAcceptsMultipleFiles = compiler.supportsMulti;

    compileJSON = function (source, optimize) {
      var missingInputs = [];

      function missingInputsCallback(path) {
        missingInputs.push(path);

        return {error: 'Deferred import'};
      }

      var result;

      try {
        result = compiler.compile(source, optimize, missingInputsCallback);
      } catch (e) {
        throw new Error(`Error compiling: ${e}`);
      }

      compilationFinished(result, missingInputs, source);
    };

    onCompilerLoaded(compiler.version());
  }

  this.loadVersion = function (version) {
    var url;

    if (version) {
      url = 'https://ethereum.github.io/solc-bin/bin/' + version;
    }

    loadInternal(url);
  };

  this.lastCompilationResult = {
    data: null,
    source: null
  };

  function compilationFinished(data, missingInputs, source) {
    var noFatalErrors = true; // ie warnings are ok

    function isValidError (error) {
      // The deferred import is not a real error
      // FIXME: maybe have a better check?
      if (/Deferred import/.exec(error)) {
        return false;
      }

      return utils.errortype(error) !== 'warning';
    }

    if (data['error'] !== undefined) {
      // Ignore warnings (and the 'Deferred import' error as those are generated by us as a workaround
      if (isValidError(data['error'])) {
        noFatalErrors = false;
      }
    }

    if (data['errors'] !== undefined) {
      data['errors'].forEach(function (err) {
        // Ignore warnings and the 'Deferred import' error as those are generated by us as a workaround
        if (isValidError(err)) {
          noFatalErrors = false;
        }
      });
    }

    if (!noFatalErrors) {
      // There are fatal errors - abort here
      self.lastCompilationResult = null;
      self.event.trigger('compilationFinished', [false, data, source]);
    } else if (missingInputs !== undefined && missingInputs.length > 0) {
      // try compiling again with the new set of inputs
      console.log(`missingInputs: ${missingInputs}`);

      internalCompile(source.sources, source.target, missingInputs);
    } else {
      data = updateInterface(data);

      self.lastCompilationResult = {
        data: data,
        source: source
      };

      self.event.trigger('compilationFinished', [true, data, source]);
    }
  }

  function gatherImports(files, target, importHints, cb) {
    importHints = importHints || [];

    if (!compilerAcceptsMultipleFiles) {
      cb(null, files[target]);

      return;
    }

    // FIXME: This will only match imports if the file begins with one.
    //        It should tokenize by lines and check each.
    // eslint-disable-next-line no-useless-escape
    var importRegex = /^\s*import\s*[\'\"]([^\'\"]+)[\'\"];/g;

    for (var fileName in files) {
      var match;

      while ((match = importRegex.exec(files[fileName]))) {
        var importFilePath = match[1];

        if (importFilePath.startsWith('./')) {
          importFilePath = importFilePath.slice(2);
        }

        // FIXME: should be using includes or sets, but there's also browser compatibility..
        if (importHints.indexOf(importFilePath) === -1) {
          importHints.push(importFilePath);
        }
      }
    }

    while (importHints.length > 0) {
      var m = importHints.pop();

      if (m in files) {
        continue;
      }

      handleImportCall(m, function (err, content) {
        if (err) {
          cb(err);
        } else {
          files[m] = content;
          gatherImports(files, target, importHints, cb);
        }
      });

      return;
    }

    cb(null, {'sources': files, 'target': target});
  }

  function truncateVersion (version) {
    var tmp = /^(\d+.\d+.\d+)/.exec(version);

    if (tmp) {
      return tmp[1];
    }

    return version;
  }

  function updateInterface (data) {
    for (var contract in data.contracts) {
      var abi = JSON.parse(data.contracts[contract].interface);
      abi = solcABI.update(truncateVersion(currentVersion), abi);
      data.contracts[contract].interface = JSON.stringify(abi);
    }

    return data;
  }
}

module.exports = Compiler;
